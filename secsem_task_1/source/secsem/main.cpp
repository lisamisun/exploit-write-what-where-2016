#include "Driver.h"
#include <ntddk.h>

NTSTATUS CompleteIrp(PDEVICE_OBJECT deviceObject, PIRP irp) {
  UNREFERENCED_PARAMETER(deviceObject);

  irp->IoStatus.Status = STATUS_SUCCESS;
  irp->IoStatus.Information = 0;

  IoCompleteRequest(irp, IO_NO_INCREMENT);

  return STATUS_SUCCESS;
}

// write-what-where
void task1(const TASK_1 *task) {
  __asm {
    push eax
    push ecx
    mov eax, dword ptr [task]       
    mov ecx, dword ptr [eax + 4]   // where
    mov eax, dword ptr [eax]       // what
    mov [eax], ecx
    pop ecx
    pop eax
  }
}

// controlled and
// note: exploit for this vuln mustn't use the first 64k of memory for allocation
void task2(const TASK_2 *task) {
  __asm {
    push eax
    push ecx
    mov eax, dword ptr [task]
    mov eax, dword ptr [eax]
    and [eax], 0
    pop ecx
    pop eax
  }
}

// pool overflow
void task3(const TASK_3 *task) {
  const auto ptr = ExAllocatePoolWithTag((POOL_TYPE)task->pool_type_, task->allocation_size_, 0x37333331);
  if (!ptr) {
    return;
  }

  memcpy(ptr, task->buffer_, task->memcpy_buffer_size_);
}

NTSTATUS DispatchIOCTLControl(PDEVICE_OBJECT deviceObject, PIRP irp) {
  UNREFERENCED_PARAMETER(deviceObject);

  const auto IrpStack = IoGetCurrentIrpStackLocation(irp);
  if (!IrpStack) {
    return CompleteIrp(nullptr, irp);
  }

  const auto controlCode = IrpStack->Parameters.DeviceIoControl.IoControlCode;

  switch (controlCode) {
  case IOCTL_TASK1:
    if (IrpStack->Parameters.DeviceIoControl.InputBufferLength != sizeof(TASK_1)) {
      return CompleteIrp(nullptr, irp);
    }
    task1((TASK_1 *)irp->AssociatedIrp.SystemBuffer);

    break;
  case IOCTL_TASK2:
    if (IrpStack->Parameters.DeviceIoControl.InputBufferLength != sizeof(TASK_2)) {
      return CompleteIrp(nullptr, irp);
    }
    task2((TASK_2 *)irp->AssociatedIrp.SystemBuffer);
    break;
  case IOCTL_TASK3:
    task3((TASK_3 *)irp->AssociatedIrp.SystemBuffer);
    break;
  }

  return CompleteIrp(nullptr, irp);
}

#pragma code_seg("PAGE")

VOID DriverUnload(IN PDRIVER_OBJECT driverObject) {
  UNICODE_STRING symlinkName;

  RtlInitUnicodeString(&symlinkName, g_SymbolicLinkName);

  ::IoDeleteSymbolicLink(&symlinkName);
  ::IoDeleteDevice(driverObject->DeviceObject);
}

#pragma code_seg() 

#pragma code_seg("INIT")

extern "C" NTSTATUS DriverEntry(struct _DRIVER_OBJECT  *driverObject, PUNICODE_STRING  registryPath) {
  UNREFERENCED_PARAMETER(registryPath);

  driverObject->DriverUnload = DriverUnload;
  driverObject->MajorFunction[IRP_MJ_CREATE] = CompleteIrp;
  driverObject->MajorFunction[IRP_MJ_CLOSE] = CompleteIrp;
  driverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchIOCTLControl;

  UNICODE_STRING devName;
  RtlInitUnicodeString(&devName, g_deviceName);

  PDEVICE_OBJECT fdo;
  auto status = IoCreateDevice(driverObject,
      0,
      &devName, 
      FILE_DEVICE_UNKNOWN,
      0,
      FALSE, 
      &fdo);

  if (!NT_SUCCESS(status)) {
    return status;
  }

  UNICODE_STRING symLinkName;
  RtlInitUnicodeString(&symLinkName, g_SymbolicLinkName);

  status = IoCreateSymbolicLink(&symLinkName, &devName);
  if (!NT_SUCCESS(status)) {
    IoDeleteDevice(fdo);
    return status;
  }

  return status;
}
#pragma code_seg() 
